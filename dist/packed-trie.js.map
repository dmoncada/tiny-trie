{"version":3,"sources":["webpack://TinyTrie/webpack/universalModuleDefinition","webpack://TinyTrie/webpack/bootstrap","webpack://TinyTrie/./src/PackedTrie.ts","webpack://TinyTrie/./src/base64.ts","webpack://TinyTrie/./src/constants.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;AC3DA,mCAA4C;AAC5C,sCASqB;AASrB,kBAAgC,QAAe,OAAa;AACxD,QAAe,YAAG,CAAE,EAAM,QAAM;AAChC,QAAoB,iBAAQ,QAAK;AACjC,QAAY,SAAiB,iBAAO;AACpC,QAAa,UAAO,KAAK,KAAO,SAAM;AACtC,QAAU,OAAG,CAAI,OAAQ,OAAK;AAC9B,QAAS,QAAK;AAEV,SAAC,IAAK,IAAI,GAAG,IAAU,SAAK,KAAG;AAC1B,kBAAO;AACP,iBAAI,SAAkB,mBAAO,OAAU,YAChD;AAAC;AAED,QAAgB,eAAS,SAAK;AAC3B,QAAc,cAAE;AACL,kBAAE,IAChB;AAAC;AAEK,WAAM,QAChB;AASA;;;AAuEI,wBAA0B;;;AAjClB,aAAQ,WAAO;AAYf,aAAY,eAAK;AAsBrB,YAAO,MAAK;AAGZ,YAAqB,kBAAW,SAAO,QAAK,KAAE,YAAoB;AAC/D,eAAI,YAAmB;AAC1B,YAAY,SAAS,OAAO,OAAE,GAAmB;AAEjD,YAAa,UAAW,SAAO,QAAK,KAAE,YAAe;AAClD,eAAI,YAAc;AAElB,YAAQ,YAAK,YAAQ,SAAE;AACtB,kBAAM,IAAU,qCAAoC,yBAAa,YACrE;AAAC;AAGG,aAAK,OAAS,OAAO,OAAkB;AAG3C,YAAgB,aAAW,SAAO,QAAK,KAAE,YAAmB;AACzD,eAAI,YAAkB;AACzB,YAAU,SAAW,SAAO,QAAK,KAAE,YAAkB;AAClD,eAAI,YAAiB;AAErB,YAAY,YAAE;AACP,qBAAG,CACb;AAAC;AAGG,aAAO,SAAU;AAGrB,YAAa,YAAW,SAAO,QAAK,KAAE,YAAkB;AACrD,eAAI,YAAiB;AAExB,YAAgB,eAAW,SAAO,QAAK,KAAE,YAAqB;AAC3D,eAAI,YAAoB;AAG3B,YAAoB,mBAAO,KAAK,KAAI,MAAM;AAC1C,YAAa,YAAS,OAAO,OAAmB;AAE5C,aAAM,kBAAkB,MAAI,IAAO,OAAC,UAAI,KAAM,MAAO;AAClD,gBAAM,QAAI,IAAK;AACZ,mBACV;AAAK,SAHiB,sBAGhB,YAAS,UAAkC;AAG7C,aAAa,eAAG,CAAC,YAAS,UAAO,OAAU,UAAM,MAAM;AAGvD,aAAU,YAAY,YAAe,eAAK;AAG1C,aAAY,cAAG,CAAI,OAAiB,gBAAK;AAGzC,aAAS,WAAG,CAAI,OAAc,aAAK;AAGnC,aAAU,YAAI,IACtB;AASI;;;;6BAAc;2FAAgC,EAAS,UAAM,MAAQ,QAAQ;gBAAtD;gBAAQ;;AAGzB,mBAAK,KAAO,OAAI,KAAE,EAAS,oBAAQ,gBAAO,OAAQ,YAC5D;AAmBM;;;+BAAc;4FAAyC,EAAS,UAAM,MAAQ,QAAO,OAAO,OAAQ;gBAA7E;gBAAQ;gBAAO;;AACrC,gBAAS,YAAY,SAAO,WAAO,GAAE;AACpC,sBAAM,IAAU,mDACpB;AAEM;gBACE,OAUC;gBATC;gBACD;gBACO;gBACH;gBACD;gBACI;gBACD;gBACF;gBAEZ;;AAGD,gBAAa,UAAM;AAGnB,gBAAW,QAAG,CAAC,EAAQ,SAAG,GAAM,MAAI,IAAO,OAAM;AACjD,gBAAe,YAAM,IAAQ;AAG7B,mBAAY,MAAO,QAAG;AAClB,oBAAU,OAAQ,MAAS;AAC3B,oBAAY,SAAO,KAAM,SAAc;AACvC,oBAAW,QAAW,SAAC,YAAU,WAAI,IAAK,KAAQ;AAGlD,oBAAY,SAAQ,UAAiB,YAAO,UAAY;AAKxD,oBAAe,cAAO,KAAS;AAC/B,uBAAW,MAAG;AAIP,wBAAC,CAAO,UAAI,CAAM,MAAe,eAAQ,QAAE;AAE9C;AAAC;AAED,wBAAU,OAAc,cAAa;AACrC,wBAAW,QAAW,SAAK,MAAM,MAAa;AAG9C,wBAAa,UAAS,SAAc,SAApB,GAAgC;AAI7C,wBAAO,UAAW,YAAU,MAAQ,QAAE;AACrC,4BAAa,UAAS,SAAiB,YAAvB,GAAsC;AAGtD,4BAAa,UAAe,aAAU;AAEnC,4BAAO,UAAW,YAAK,YAAS,UAAE;AAE9B,gCAAO,OAAE;AACF,uCAAK,KACf;AAAC;AAEM,oCAAK,KAAK,KAAO;AAGrB,gCAAC,CAAQ,QAAE;AAEd;AACJ;AAAC;AAGE,4BAAQ,YAAK,YAAS,UAAE;AAClB,kCAAK;AACC,yCAAa,cAAS,SAAU;AAClC,uCAAM,KAAM,QAAI;AACjB,sCAAM,KAAK,OAEvB;AALe;AAMnB;AAAC;AAID,wBAAU,OAAQ,QAAY;AAG3B,wBAAM,MAAE;AAEX;AAEI,2BAAE;AACS,uCACf;AACJ;AACJ;AAAC;AAIK,mBAAQ,QAAO,OACzB;AAEH;;;;;;AA5QD,qBA4QC,W;;;;;;;;;;;;;;;AC1TY,QAAkB,qBAK9B,mEAAM,MAAK;AAOC,QAAkB,6BAAqB,mBAAO,OAAC,UAAI,KAAM,MAAO;AACtE,QAAM,QAAK;AACR,WACV;AAAC,CAHiC,EAGA,I;;;;;;;;;;;;;;;AChBrB,QAAQ,WAAQ;AAMhB,QAAQ,WAAS,OAAO,OAAO;AAM/B,QAAO,UAAK;AAOZ,QAAkB,qBAAM;AAMxB,QAAa,gBAAM;AAMnB,QAAiB,oBAAK;AAMtB,QAAgB,mBAAM;AAMtB,QAAgB,mBAAK;AAMrB,QAAmB,sBAAK,E","file":"packed-trie.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TinyTrie\"] = factory();\n\telse\n\t\troot[\"TinyTrie\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/PackedTrie.ts\");\n","/**\n * @file Small class for querying a binary-encoded Trie\n *\n * TODO - rewrite as a native class. Babel adds a lot of overhead. This class\n * should be tiny and transparent.\n */\n\nimport {ITrie, ISearchOpts, ITestOpts} from './BaseTrie';\nimport {BASE64_CHAR_TO_INT} from './base64';\nimport {\n    TERMINAL,\n    VERSION,\n    HEADER_WIDTH_FIELD,\n    VERSION_FIELD,\n    OFFSET_SIGN_FIELD,\n    OFFSET_VAL_FIELD,\n    CHAR_WIDTH_FIELD,\n    POINTER_WIDTH_FIELD\n} from './constants';\n\n/**\n * Extract a window of bits from a Base64 encoded sequence\n * @param  {String} binary - base64 encoded sequence\n * @param  {Number} start - first bit to read\n * @param  {Number} len - number of bits to read\n * @return {Number} - bits from string, as number\n */\nfunction readBits(binary: string, start: number, len: number) {\n    const startChar = ~~(start / 6);\n    const startBitOffset = start % 6;\n    const endBit = startBitOffset + len;\n    const charLen = Math.ceil(endBit / 6);\n    const mask = (0x1 << len) - 1;\n    let chunk = 0;\n\n    for (let i = 0; i < charLen; i++) {\n        chunk <<= 6;\n        chunk |= BASE64_CHAR_TO_INT[binary[startChar + i]];\n    }\n\n    let rightPadding = endBit % 6;\n    if (rightPadding) {\n        chunk >>= (6 - rightPadding);\n    }\n\n    return chunk & mask;\n}\n\n/**\n * Class for interacting with an encoded trie. The class performs lookups\n * virtually just as fast as a regular trie. The binary data never actually\n * have to be processed as a whole, so instantiation time and memory usage are\n * phenomenally low.\n * @class\n */\nexport class PackedTrie implements ITrie {\n\n    /**\n     * Binary string encoded as Base64 representing Trie\n     * @type {String}\n     */\n    public data: string;\n\n    /**\n     * Pointer offset. Add this to every pointer read from every word in\n     * the trie to obtain the true value of the pointer. This offset is\n     * used to avoid signed integers in the word.\n     * @type {Number}\n     */\n    private offset: number;\n\n    /**\n     * Character table, mapping character to an integer ID\n     * @type {Object}\n     */\n    private table: {[key: string]: number};\n\n    /**\n     * Inverse of character table, mapping integer ID to character.\n     * @type {Array}\n     */\n    private inverseTable: {[key: number]: string};\n\n    /**\n     * Number of bits in one word\n     * @type {Number}\n     */\n    private wordWidth: number;\n\n    /**\n     * Mask for reading the \"last block\" flag in a word\n     * @type {Number}\n     */\n    private lastMask = 0x1;\n\n    /**\n     * Mask for reading the pointer value from a word\n     * @type {Number}\n     */\n    private pointerMask: number;\n\n    /**\n     * Offset of pointer field in a word\n     * @type {Number}\n     */\n    private pointerShift = 1;\n\n    /**\n     * Mask for reading the charTable index in a word\n     * @type {Number}\n     */\n    private charMask: number;\n\n    /**\n     * Offset of charTable index field in a word\n     * @type {Number}\n     */\n    private charShift: number;\n\n    /**\n     * Instantiate a packed binary trie, parsing its headers to configure the\n     * instance for queries.\n     * @constructor\n     * @param  {String} binary - binary string from {@link Trie#encode}\n     * @return {PackedTrie}\n     */\n    constructor(binary: string) {\n        let ptr = 0;\n\n        // Split binary into header and content by checking first field\n        const headerCharCount = readBits(binary, ptr, HEADER_WIDTH_FIELD);\n        ptr += HEADER_WIDTH_FIELD;\n        const header = binary.substr(0, headerCharCount);\n\n        const version = readBits(binary, ptr, VERSION_FIELD);\n        ptr += VERSION_FIELD;\n\n        if (version !== VERSION) {\n            throw new Error(`Version mismatch! Binary: ${version}, Reader: ${VERSION}`);\n        }\n\n        // Main trie data\n        this.data = binary.substr(headerCharCount);\n\n        // compute pointer offset\n        const offsetSign = readBits(header, ptr, OFFSET_SIGN_FIELD);\n        ptr += OFFSET_SIGN_FIELD;\n        let offset = readBits(header, ptr, OFFSET_VAL_FIELD);\n        ptr += OFFSET_VAL_FIELD;\n\n        if (offsetSign) {\n            offset = -offset;\n        }\n\n        // Pointer offset\n        this.offset = offset;\n\n        // interpret the field width within each word\n        let charWidth = readBits(header, ptr, CHAR_WIDTH_FIELD);\n        ptr += CHAR_WIDTH_FIELD;\n\n        let pointerWidth = readBits(header, ptr, POINTER_WIDTH_FIELD);\n        ptr += POINTER_WIDTH_FIELD;\n\n        // Interpret the rest of the header as the charTable\n        let headerFieldChars = Math.ceil(ptr / 6);\n        let charTable = header.substr(headerFieldChars);\n\n        this.table = charTable.split('').reduce((agg, char, i) => {\n            agg[char] = i + 1;\n            return agg;\n        }, { [TERMINAL]: 0 } as {[key: string]: number});\n\n        // Construct inverse table\n        this.inverseTable = [TERMINAL].concat(charTable.split(''));\n\n        // Number of bits in a word\n        this.wordWidth = charWidth + pointerWidth + 1;\n\n        // Mask for reading pointer\n        this.pointerMask = (0x1 << pointerWidth) - 1;\n\n        // Mask for reading characters\n        this.charMask = (0x1 << charWidth) - 1;\n\n        // Offset of charTable\n        this.charShift = 1 + pointerWidth;\n    }\n\n    /**\n     * Test membership in the trie.\n     * @param  {String} str - Search query\n     * @param  {String?} opts.wildcard - See PackedTrie#search wildcard doc\n     * @param  {Boolean?} opts.prefix - See PackedTrie#search prefix doc\n     * @return {Boolean}\n     */\n    test(str: string, {wildcard, prefix}: ITestOpts = {wildcard: null, prefix: false}) {\n        // Delegate to #search with early exit. Could write an optimized path,\n        // especially for the prefix search case.\n        return this.search(str, {wildcard, prefix, first: true}) !== null;\n    }\n\n    /**\n     * Query for matching words in the trie.\n     * @param  {String} str - Search query\n     * @param  {String?} opts.wildcard - Wildcard to use for fuzzy matching.\n     *                                   Default is no wildcard; only match\n     *                                   literal query.\n     * @param  {Boolean?} opts.prefix - Perform prefix search (returns true if\n     *                                  any word exists in the trie starts with\n     *                                  the search query). Default is false;\n     *                                  only match the full query.\n     * @param  {Boolean} opts.first - Return only first match that is found,\n     *                                short-circuiting the search. Default is\n     *                                false; return all matches.\n     * @return {String?|String[]} - Return an optional string result when in\n     *                              first-only mode; otherwise return a list\n     *                              of strings that match the query.\n     */\n    search(str: string, {wildcard, prefix, first}: ISearchOpts = {wildcard: null, prefix: false, first: false}) {\n        if (wildcard && wildcard.length !== 1) {\n            throw new Error(`Wilcard must be a single character; got ${wildcard}`);\n        }\n\n        const {\n            data,\n            offset,\n            table,\n            inverseTable,\n            wordWidth,\n            lastMask,\n            pointerShift,\n            pointerMask,\n            charShift,\n            charMask\n        } = this;\n\n        // List of matches found in the search.\n        const matches = [];\n\n        // Search queue.\n        const queue = [{pointer: 0, memo: '', depth: 0}];\n        const lastDepth = str.length;\n\n        // Do a BFS over nodes for the search query.\n        while (queue.length) {\n            const node = queue.shift();\n            const isLast = node.depth >= lastDepth;\n            const token = isLast ? TERMINAL : str[node.depth];\n            // Flag for matching anything. Note that the overflow beyond the\n            // length of the query in a prefix search behaves as a wildcard.\n            const isWild = token === wildcard || (prefix && isLast);\n            // We're committed to an O(N) scan over the entire node even in\n            // the simple literal-search case, since our structure doesn't\n            // currently guarantee any child ordering.\n            // TODO(joen) ordering is a potential future format optimization.\n            let wordPointer = node.pointer;\n            while (true) {\n                // Optimization: Exit immediately if the char was not found in\n                // the table (meaning there can't be any children in the trie\n                // with this character). Exception is wildcards.\n                if (!isWild && !table.hasOwnProperty(token)) {\n                    break;\n                }\n\n                const bits = wordPointer * wordWidth;\n                const chunk = readBits(data, bits, wordWidth);\n\n                // Read the character index\n                const charIdx = (chunk >> charShift) & charMask;\n\n                // If this character is matched, jump to the pointer given in\n                // this node.\n                if (isWild || charIdx === table[token]) {\n                    const pointer = (chunk >> pointerShift) & pointerMask;\n                    // Find the next char with an inverse map, since we might\n                    // be using a wildcard search.\n                    const newChar = inverseTable[charIdx];\n                    // Stopping condition: searching last block and we hit a terminal\n                    if (isLast && newChar === TERMINAL) {\n                        // Optimization: early exit if we only need first match.\n                        if (first) {\n                            return node.memo;\n                        }\n                        // Store this match.\n                        matches.push(node.memo);\n                        // If we're not matching everything, break out of the\n                        // inner loop.\n                        if (!isWild) {\n                            break;\n                        }\n                    }\n\n                    // Push next node for search, if it's non-terminal.\n                    if (newChar !== TERMINAL) {\n                        queue.push({\n                            pointer: wordPointer + offset + pointer,\n                            depth: node.depth + 1,\n                            memo: node.memo + newChar,\n                        });\n                    }\n                }\n\n                // If this wasn't a match, check if this was the last key in\n                // the block.\n                const last = chunk & lastMask;\n\n                // If this was the last node, the word was not found.\n                if (last) {\n                    break;\n                }\n                // Otherwise increment the pointer to the next sibling key\n                else {\n                    wordPointer += 1;\n                }\n            }\n        }\n\n        // If first was requested it should have returned by now. Otherwise\n        // return the matches list, which may be empty.\n        return first ? null : matches;\n    }\n\n}\n","/**\n * @file Lookup tables for Base64 conversions\n */\n\n/**\n * Lookup table for transforming a 6-bit binary integer into a Base-64 ASCII\n * character.\n * @constant {String[]}\n */\nexport const BASE64_INT_TO_CHAR = `\\\nABCDEFGHIJKLMNOPQRSTUVWXYZ\\\nabcdefghijklmnopqrstuvwxyz\\\n0123456789\\\n+/\\\n`.split('');\n\n/**\n * Inverse lookup table for transformating a Base-64 ASCII character into the\n * corresponding integer value.\n * @constant {Object}\n */\nexport const BASE64_CHAR_TO_INT = BASE64_INT_TO_CHAR.reduce((agg, char, i) => {\n    agg[char] = i;\n    return agg;\n}, {} as {[key: string]: number});\n","/**\n * @file Parameters used for encoding\n */\n\n/**\n * String terminal character\n * @constant {String}\n */\nexport const TERMINAL = '\\0';\n\n/**\n * Terminal edge\n * @constant {Object}\n */\nexport const TERMINUS = Object.create(null);\n\n/**\n * Encoding version. Bump when breaking encoding changes are introduced.\n * @constant {Number}\n */\nexport const VERSION = 0;\n\n/**\n * Width of header field storing entire header width (including char table).\n * Value is given in Base64 characters (i.e., every six bits)\n * @constant {Number}\n */\nexport const HEADER_WIDTH_FIELD = 10;\n\n/**\n * Width of version field\n * @type {Number}\n */\nexport const VERSION_FIELD = 10;\n\n/**\n * Width of header field representing sign of offset\n * @constant {Number}\n */\nexport const OFFSET_SIGN_FIELD = 1;\n\n/**\n * Width of header field representing unsigned value of offset\n * @constant {Number}\n */\nexport const OFFSET_VAL_FIELD = 21;\n\n/**\n * Width of header field representing the width of the char index in a word\n * @constant {Number}\n */\nexport const CHAR_WIDTH_FIELD = 8;\n\n/**\n * Width of header field representing the width of the offset pointer in a word\n * @constant {Number}\n */\nexport const POINTER_WIDTH_FIELD = 8;\n"],"sourceRoot":""}