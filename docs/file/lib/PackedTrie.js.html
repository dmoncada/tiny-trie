<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/PackedTrie.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="git+https://github.com/jnu/tiny-tree.git">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/BinaryString.js~BinaryString.html">BinaryString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/PackedTrie.js~PackedTrie.html">PackedTrie</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Trie.js~Trie.html">Trie</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-floor_log2">floor_log2</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createFrozenSync">createFrozenSync</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createSync">createSync</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-binaryString">binaryString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-packedTrie">packedTrie</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-trie">trie</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-BASE64_CHAR_TO_INT">BASE64_CHAR_TO_INT</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-BASE64_INT_TO_CHAR">BASE64_INT_TO_CHAR</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CHAR_WIDTH_FIELD">CHAR_WIDTH_FIELD</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-HEADER_WIDTH_FIELD">HEADER_WIDTH_FIELD</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-OFFSET_SIGN_FIELD">OFFSET_SIGN_FIELD</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-OFFSET_VAL_FIELD">OFFSET_VAL_FIELD</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-POINTER_WIDTH_FIELD">POINTER_WIDTH_FIELD</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TERMINAL">TERMINAL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TERMINUS">TERMINUS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-VERSION">VERSION</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-VERSION_FIELD">VERSION_FIELD</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/PackedTrie.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * @file Small class for querying a binary-encoded Trie
 *
 * TODO - rewrite as a native class. Babel adds a lot of overhead. This class
 * should be tiny and transparent.
 */

import {BASE64_CHAR_TO_INT} from &apos;./base64&apos;;
import {
    TERMINAL,
    VERSION,
    HEADER_WIDTH_FIELD,
    VERSION_FIELD,
    OFFSET_SIGN_FIELD,
    OFFSET_VAL_FIELD,
    CHAR_WIDTH_FIELD,
    POINTER_WIDTH_FIELD
} from &apos;./constants&apos;;


/**
 * Extract a window of bits from a Base64 encoded sequence
 * @param  {String} binary - base64 encoded sequence
 * @param  {Number} start - first bit to read
 * @param  {Number} len - number of bits to read
 * @return {Number} - bits from string, as number
 */
function readBits(binary, start, len) {
    let startChar = ~~(start / 6);
    let startBitOffset = start % 6;
    let endBit = startBitOffset + len;
    let charLen = Math.ceil(endBit / 6);
    let mask = (0x1 &lt;&lt; len) - 1;
    let chunk = 0;

    for (let i = 0; i &lt; charLen; i++) {
        chunk &lt;&lt;= 6;
        chunk |= BASE64_CHAR_TO_INT[binary[startChar + i]];
    }

    let rightPadding = endBit % 6;
    if (rightPadding) {
        chunk &gt;&gt;= (6 - rightPadding);
    }

    return chunk &amp; mask;
}

/**
 * Class for interacting with an encoded trie. The class performs lookups
 * virtually just as fast as a regular trie. The binary data never actually
 * have to be processed as a whole, so instantiation time and memory usage are
 * phenomenally low.
 * @class
 */
class PackedTrie {

    /**
     * Instantiate a packed binary trie, parsing its headers to configure the
     * instance for queries.
     * @constructor
     * @param  {String} binary - binary string from {@link Trie#encode}
     * @return {PackedTrie}
     */
    constructor(binary) {
        let ptr = 0;

        // Split binary into header and content by checking first field
        let headerCharCount = readBits(binary, ptr, HEADER_WIDTH_FIELD);
        ptr += HEADER_WIDTH_FIELD;
        let header = binary.substr(0, headerCharCount);

        let version = readBits(binary, ptr, VERSION_FIELD);
        ptr += VERSION_FIELD;

        if (version !== VERSION) {
            throw new Error(`Version mismatch! Binary: ${version}, Reader: ${VERSION}`);
        }

        /**
         * Binary string encoded as Base64 representing Trie
         * @type {String}
         */
        this.data = binary.substr(headerCharCount);

        // compute pointer offset

        let offsetSign = readBits(header, ptr, OFFSET_SIGN_FIELD);
        ptr += OFFSET_SIGN_FIELD;
        let offset = readBits(header, ptr, OFFSET_VAL_FIELD);
        ptr += OFFSET_VAL_FIELD;

        if (offsetSign) {
            offset = -offset;
        }
        /**
         * Pointer offset. Add this to every pointer read from every word in
         * the trie to obtain the true value of the pointer. This offset is
         * used to avoid signed integers in the word.
         * @type {Number}
         */
        this.offset = offset;

        // interpret the field width within each word
        let charWidth = readBits(header, ptr, CHAR_WIDTH_FIELD);
        ptr += CHAR_WIDTH_FIELD;

        let pointerWidth = readBits(header, ptr, POINTER_WIDTH_FIELD);
        ptr += POINTER_WIDTH_FIELD;

        // Interpret the rest of the header as the charTable
        let headerFieldChars = Math.ceil(ptr / 6);
        let charTable = header.substr(headerFieldChars);

        /**
         * Character table, mapping character to an integer ID
         * @type {Object}
         */
        this.table = charTable.split(&apos;&apos;).reduce((agg, char, i) =&gt; {
            agg[char] = i + 1;
            return agg;
        }, { [TERMINAL]: 0 });

        /**
         * Inverse of character table, mapping integer ID to character.
         * @type {Array}
         */
        this.inverseTable = [TERMINAL].concat(charTable.split(&apos;&apos;));

        /**
         * Number of bits in one word
         * @type {Number}
         */
        this.wordWidth = charWidth + pointerWidth + 1;

        /**
         * Mask for reading the &quot;last block&quot; flag in a word
         * @type {Number}
         */
        this.lastMask = 0x1;

        /**
         * Mask for reading the pointer value from a word
         * @type {Number}
         */
        this.pointerMask = (0x1 &lt;&lt; pointerWidth) - 1;

        /**
         * Offset of pointer field in a word
         * @type {Number}
         */
        this.pointerShift = 1;

        /**
         * Mask for reading the charTable index in a word
         * @type {Number}
         */
        this.charMask = (0x1 &lt;&lt; charWidth) - 1;

        /**
         * Offset of charTable index field in a word
         * @type {Number}
         */
        this.charShift = 1 + pointerWidth;
    }

    /**
     * Test membership in the trie.
     * @param  {String} string - Search query
     * @param  {String?} opts.wildcard - See PackedTrie#search wildcard doc
     * @param  {Boolean?} opts.prefix - See PackedTrie#search prefix doc
     * @return {Boolean}
     */
    test(string, {wildcard, prefix} = {wildcard: null, prefix: false}) {
        // Delegate to #search with early exit. Could write an optimized path,
        // especially for the prefix search case.
        return this.search(string, {wildcard, prefix, first: true}) !== null;
    }

    /**
     * Query for matching words in the trie.
     * @param  {String} string - Search query
     * @param  {String?} opts.wildcard - Wildcard to use for fuzzy matching.
     *                                   Default is no wildcard; only match
     *                                   literal query.
     * @param  {Boolean?} opts.prefix - Perform prefix search (returns true if
     *                                  any word exists in the trie starts with
     *                                  the search query). Default is false;
     *                                  only match the full query.
     * @param  {Boolean} opts.first - Return only first match that is found,
     *                                short-circuiting the search. Default is
     *                                false; return all matches.
     * @return {String?|String[]} - Return an optional string result when in
     *                              first-only mode; otherwise return a list
     *                              of strings that match the query.
     */
    search(string, {wildcard, prefix, first} = {wildcard: null, prefix: false, first: false}) {
        if (wildcard &amp;&amp; wildcard.length !== 1) {
            throw new Error(`Wilcard must be a single character; got ${wildcard}`);
        }

        const {
            data,
            offset,
            table,
            inverseTable,
            wordWidth,
            lastMask,
            pointerShift,
            pointerMask,
            charShift,
            charMask
        } = this;

        // List of matches found in the search.
        const matches = [];

        // Search queue.
        const queue = [{pointer: 0, memo: &apos;&apos;, depth: 0}];
        const lastDepth = string.length;

        // Do a BFS over nodes for the search query.
        while (queue.length) {
            const node = queue.shift();
            const isLast = node.depth &gt;= lastDepth;
            const token = isLast ? TERMINAL : string[node.depth];
            // Flag for matching anything. Note that the overflow beyond the
            // length of the query in a prefix search behaves as a wildcard.
            const isWild = token === wildcard || (prefix &amp;&amp; isLast);
            // We&apos;re committed to an O(N) scan over the entire node even in
            // the simple literal-search case, since our structure doesn&apos;t
            // currently guarantee any child ordering.
            // TODO(joen) ordering is a potential future format optimization.
            let wordPointer = node.pointer;
            while (true) {
                // Optimization: Exit immediately if the char was not found in
                // the table (meaning there can&apos;t be any children in the trie
                // with this character). Exception is wildcards.
                if (!isWild &amp;&amp; !table.hasOwnProperty(token)) {
                    break;
                }

                const bits = wordPointer * wordWidth;
                const chunk = readBits(data, bits, wordWidth);

                // Read the character index
                const charIdx = (chunk &gt;&gt; charShift) &amp; charMask;

                // If this character is matched, jump to the pointer given in
                // this node.
                if (isWild || charIdx === table[token]) {
                    const pointer = (chunk &gt;&gt; pointerShift) &amp; pointerMask;
                    // Find the next char with an inverse map, since we might
                    // be using a wildcard search.
                    const newChar = inverseTable[charIdx];
                    // Stopping condition: searching last block and we hit a terminal
                    if (isLast &amp;&amp; newChar === TERMINAL) {
                        // Optimization: early exit if we only need first match.
                        if (first) {
                            return node.memo;
                        }
                        // Store this match.
                        matches.push(node.memo);
                        // If we&apos;re not matching everything, break out of the
                        // inner loop.
                        if (!isWild) {
                            break;
                        }
                    }

                    // Push next node for search, if it&apos;s non-terminal.
                    if (newChar !== TERMINAL) {
                        queue.push({
                            pointer: wordPointer + offset + pointer,
                            depth: node.depth + 1,
                            memo: node.memo + newChar,
                        });
                    }
                }

                // If this wasn&apos;t a match, check if this was the last key in
                // the block.
                const last = chunk &amp; lastMask;

                // If this was the last node, the word was not found.
                if (last) {
                    break;
                }
                // Otherwise increment the pointer to the next sibling key
                else {
                    wordPointer += 1;
                }
            }
        }

        // If first was requested it should have returned by now. Otherwise
        // return the matches list, which may be empty.
        return first ? null : matches;
    }

}

export default PackedTrie;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
